{"remainingRequest":"/Users/juhongchul/Desktop/개발/MEVN/4장/sensor/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/juhongchul/Desktop/개발/MEVN/4장/sensor/src/components/Chart.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/juhongchul/Desktop/개발/MEVN/4장/sensor/src/components/Chart.vue","mtime":1567660199398},{"path":"/Users/juhongchul/Desktop/개발/MEVN/4장/sensor/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/juhongchul/Desktop/개발/MEVN/4장/sensor/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/juhongchul/Desktop/개발/MEVN/4장/sensor/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/juhongchul/Desktop/개발/MEVN/4장/sensor/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n\n  import config from '../config'\n  import * as d3 from 'd3'\n  const margin_value = 1;\n  const keyToHanguel = {\n    \"wv\" : \"풍속\", \n    \"temp\" : \"온도\", \n    \"humi\" : \"습도\"\n  }\n\n  const timeFormat = d3.timeFormat(\"%H:%M\")\n  import {\n    mapState\n  } from 'vuex'\nexport default {\n    name: 'Chart',\n    props: {\n      _key: String,\n      color: String\n    },\n    data() {\n      return {\n        svg: \"\",\n        xScale: \"\",\n        yScale: \"\",\n        xAxis: \"\",\n        yAxis: \"\",\n        line: \"\", \n        tooltip: \"\", \n        circle: \"\"\n      }\n    },\n    mounted() {\n      this.setAreaAndScale(this._key);\n      let cnt = 0;\n      this.$store.subscribe((mutation, state) => {\n        if (mutation.type === \"CHANGE_SENSOR_CHART\") {\n          if (!cnt) this.initDraw(this.sensors, this._key);\n          else{\n            console.log(1)\n            this.draw(this.sensors, this._key);\n          }\n          cnt = 1; \n        }\n\n      })\n    },\n    methods: {\n      setAreaAndScale(key) {\n        this.svg = d3.select(`.Chart-${key}`).append(\"svg\")\n          .attr(\"width\", config.chartWidth + config.margin.left + config.margin.right)\n          .attr(\"height\", config.chartHeight + config.margin.top + config.margin.bottom)\n          .append(\"g\")\n          .attr(\"transform\", `translate(${config.margin.left},${config.margin.top})`)\n          \n        this.xScale = d3.scaleTime().range([0, config.chartWidth])\n        this.yScale = d3.scaleLinear().range([config.chartHeight, 0])\n \n        this.xAxis = d3.axisBottom(this.xScale).tickFormat(timeFormat)\n        this.yAxis = d3.axisLeft(this.yScale)\n        this.line = d3.line().x(d => this.xScale(d.time)).y(d => this.yScale(d[key])).curve(d3.curveMonotoneX)\n        \n        this.tooltip = d3.select(`.tooltip`)    \n      },\n      initDraw(data, key) { \n        //data는 string형태로 오기 때문에 여기서 new Date 객체로 바꿔주어야 합니다. \n        data.forEach(d =>  d.time = new Date(d.time));\n        //scale에는 extent또는 0부터 max까지 할 수있다. \n        this.xScale.domain(d3.extent(data, d => d.time))\n        //yScale.domain([0, d3.max(data, d => d.temp)])  \n        const _min = d3.min(data, d => d[key])\n        const _max = d3.max(data, d => d[key])\n        this.yScale.domain([_min - margin_value, _max + margin_value])\n\n        //data를 통해 path를 그리는데 3가지 방법이 있다. \n        // svg.append(\"path\").datum(data).attr(\"d\", line)\n        // svg.append(\"path\").data([data]).attr(\"d\", line) \n        this.svg.append(\"path\")\n          .attr(\"d\", this.line(data))\n          .attr(\"class\", \"line\")\n        this.svg.append(\"g\")\n          .attr(\"class\", \"x axis\")\n          .attr(\"transform\", `translate(0,${config.chartHeight})`)\n          .call(this.xAxis);\n        this.svg.append(\"g\")\n          .attr(\"class\", \"y axis\")\n          .call(this.yAxis); \n  \n        this.circle = this.svg.selectAll(\"dot\")\t\n                          .data(data)\t\t\t\n                          .enter().append(\"circle\")\t\t\t\t\t\t\t\t\n                          .attr(\"r\", 5)\t\n                          .on(\"mouseover\", d => {\t \n                            this.tooltip.transition()\t\t\n                                .duration(200)\t\t  \n                                .style(\"opacity\", 1) \n                            const content = `<p>${keyToHanguel[key]}</p> <p>[${timeFormat(d.time)}]</p><h2>${d[key]}</h2>`\n\n                            this.tooltip\n                                .html(content)\t\n                                .style(\"left\", (d3.event.pageX) - 83 + \"px\")\t\t\n                                .style(\"top\", (d3.event.pageY) - 130 + \"px\")   \n                          })\t\t\t\t\t\n                          .on(\"mouseout\", d =>{\t\n                              this.tooltip.transition()\t\t\n                                  .duration(200)\t\t\n                                  .style(\"opacity\", 0);\t\n                          });\n \n        this.circle\t\n          .attr(\"cx\", d => this.xScale(d.time))\t\t \n          .attr(\"cy\", d => this.yScale(d[key]))\t\t \n      },\n      //draw에서는 데이터 처리가 아닌 data를 통해서 차트틀 그리는 것에 대해 집중해야 한다. \n      draw(data, key) { \n        data.forEach(d =>d.time = new Date(d.time));\n \n        const _min = d3.min(data, d => d[key])\n        const _max = d3.max(data, d => d[key])\n        this.xScale.domain(d3.extent(data, d => d.time)) \n        this.yScale.domain([_min - margin_value, _max + margin_value]) \n        this.svg.select(\".line\")\n          .transition()\n          .duration(750)\n          .attr(\"d\", this.line(data));\n        this.svg.select(\".x.axis\")  \n          .transition()\n          .duration(750)\n          .call(this.xAxis);\n        this.svg.select(\".y.axis\") \n          .transition() \n          .duration(750)\n          .call(this.yAxis); \n\n        this.circle\t\n          .data(data)\n          .transition()\n          .duration(750)\n          .attr(\"cx\", d => this.xScale(d.time))\t\t \n          .attr(\"cy\", d => this.yScale(d[key]))\t  \n      }\n    },\n    computed: {\n      ...mapState([\n        'sensors'\n      ])\n    }\n  }\n",{"version":3,"sources":["Chart.vue"],"names":[],"mappings":";;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Chart.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div :class=\"`Chart Chart-${_key}`\">\n  </div>\n</template>\n\n<script>\n  import config from '../config'\n  import * as d3 from 'd3'\n  const margin_value = 1;\n  const keyToHanguel = {\n    \"wv\" : \"풍속\", \n    \"temp\" : \"온도\", \n    \"humi\" : \"습도\"\n  }\n\n  const timeFormat = d3.timeFormat(\"%H:%M\")\n  import {\n    mapState\n  } from 'vuex'\nexport default {\n    name: 'Chart',\n    props: {\n      _key: String,\n      color: String\n    },\n    data() {\n      return {\n        svg: \"\",\n        xScale: \"\",\n        yScale: \"\",\n        xAxis: \"\",\n        yAxis: \"\",\n        line: \"\", \n        tooltip: \"\", \n        circle: \"\"\n      }\n    },\n    mounted() {\n      this.setAreaAndScale(this._key);\n      let cnt = 0;\n      this.$store.subscribe((mutation, state) => {\n        if (mutation.type === \"CHANGE_SENSOR_CHART\") {\n          if (!cnt) this.initDraw(this.sensors, this._key);\n          else{\n            console.log(1)\n            this.draw(this.sensors, this._key);\n          }\n          cnt = 1; \n        }\n\n      })\n    },\n    methods: {\n      setAreaAndScale(key) {\n        this.svg = d3.select(`.Chart-${key}`).append(\"svg\")\n          .attr(\"width\", config.chartWidth + config.margin.left + config.margin.right)\n          .attr(\"height\", config.chartHeight + config.margin.top + config.margin.bottom)\n          .append(\"g\")\n          .attr(\"transform\", `translate(${config.margin.left},${config.margin.top})`)\n          \n        this.xScale = d3.scaleTime().range([0, config.chartWidth])\n        this.yScale = d3.scaleLinear().range([config.chartHeight, 0])\n \n        this.xAxis = d3.axisBottom(this.xScale).tickFormat(timeFormat)\n        this.yAxis = d3.axisLeft(this.yScale)\n        this.line = d3.line().x(d => this.xScale(d.time)).y(d => this.yScale(d[key])).curve(d3.curveMonotoneX)\n        \n        this.tooltip = d3.select(`.tooltip`)    \n      },\n      initDraw(data, key) { \n        //data는 string형태로 오기 때문에 여기서 new Date 객체로 바꿔주어야 합니다. \n        data.forEach(d =>  d.time = new Date(d.time));\n        //scale에는 extent또는 0부터 max까지 할 수있다. \n        this.xScale.domain(d3.extent(data, d => d.time))\n        //yScale.domain([0, d3.max(data, d => d.temp)])  \n        const _min = d3.min(data, d => d[key])\n        const _max = d3.max(data, d => d[key])\n        this.yScale.domain([_min - margin_value, _max + margin_value])\n\n        //data를 통해 path를 그리는데 3가지 방법이 있다. \n        // svg.append(\"path\").datum(data).attr(\"d\", line)\n        // svg.append(\"path\").data([data]).attr(\"d\", line) \n        this.svg.append(\"path\")\n          .attr(\"d\", this.line(data))\n          .attr(\"class\", \"line\")\n        this.svg.append(\"g\")\n          .attr(\"class\", \"x axis\")\n          .attr(\"transform\", `translate(0,${config.chartHeight})`)\n          .call(this.xAxis);\n        this.svg.append(\"g\")\n          .attr(\"class\", \"y axis\")\n          .call(this.yAxis); \n  \n        this.circle = this.svg.selectAll(\"dot\")\t\n                          .data(data)\t\t\t\n                          .enter().append(\"circle\")\t\t\t\t\t\t\t\t\n                          .attr(\"r\", 5)\t\n                          .on(\"mouseover\", d => {\t \n                            this.tooltip.transition()\t\t\n                                .duration(200)\t\t  \n                                .style(\"opacity\", 1) \n                            const content = `<p>${keyToHanguel[key]}</p> <p>[${timeFormat(d.time)}]</p><h2>${d[key]}</h2>`\n\n                            this.tooltip\n                                .html(content)\t\n                                .style(\"left\", (d3.event.pageX) - 83 + \"px\")\t\t\n                                .style(\"top\", (d3.event.pageY) - 130 + \"px\")   \n                          })\t\t\t\t\t\n                          .on(\"mouseout\", d =>{\t\n                              this.tooltip.transition()\t\t\n                                  .duration(200)\t\t\n                                  .style(\"opacity\", 0);\t\n                          });\n \n        this.circle\t\n          .attr(\"cx\", d => this.xScale(d.time))\t\t \n          .attr(\"cy\", d => this.yScale(d[key]))\t\t \n      },\n      //draw에서는 데이터 처리가 아닌 data를 통해서 차트틀 그리는 것에 대해 집중해야 한다. \n      draw(data, key) { \n        data.forEach(d =>d.time = new Date(d.time));\n \n        const _min = d3.min(data, d => d[key])\n        const _max = d3.max(data, d => d[key])\n        this.xScale.domain(d3.extent(data, d => d.time)) \n        this.yScale.domain([_min - margin_value, _max + margin_value]) \n        this.svg.select(\".line\")\n          .transition()\n          .duration(750)\n          .attr(\"d\", this.line(data));\n        this.svg.select(\".x.axis\")  \n          .transition()\n          .duration(750)\n          .call(this.xAxis);\n        this.svg.select(\".y.axis\") \n          .transition() \n          .duration(750)\n          .call(this.yAxis); \n\n        this.circle\t\n          .data(data)\n          .transition()\n          .duration(750)\n          .attr(\"cx\", d => this.xScale(d.time))\t\t \n          .attr(\"cy\", d => this.yScale(d[key]))\t  \n      }\n    },\n    computed: {\n      ...mapState([\n        'sensors'\n      ])\n    }\n  }\n</script>\n\n<style> \n.Chart{\n  position:relative;\n}\n.Chart .line {\n  fill: none;\n  stroke: #f89e35;\n  stroke-width: 2px;\n}\n.Chart-humi .line{ \n  stroke: #42b983; \n} \n.Chart-wv .line{ \n  stroke: #262d3d; \n} \n\ncircle {\n  fill: rgba(40, 53, 79, .95);\n}\n</style>"]}]}